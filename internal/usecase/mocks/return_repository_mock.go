// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

import (
	"context"
	"homework-1/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ReturnRepositoryMock implements mm_repository.ReturnRepository
type ReturnRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddReturn          func(ctx context.Context, ret *domain.Return) (err error)
	funcAddReturnOrigin    string
	inspectFuncAddReturn   func(ctx context.Context, ret *domain.Return)
	afterAddReturnCounter  uint64
	beforeAddReturnCounter uint64
	AddReturnMock          mReturnRepositoryMockAddReturn

	funcListReturns          func(ctx context.Context) (rpa1 []*domain.Return, err error)
	funcListReturnsOrigin    string
	inspectFuncListReturns   func(ctx context.Context)
	afterListReturnsCounter  uint64
	beforeListReturnsCounter uint64
	ListReturnsMock          mReturnRepositoryMockListReturns
}

// NewReturnRepositoryMock returns a mock for mm_repository.ReturnRepository
func NewReturnRepositoryMock(t minimock.Tester) *ReturnRepositoryMock {
	m := &ReturnRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddReturnMock = mReturnRepositoryMockAddReturn{mock: m}
	m.AddReturnMock.callArgs = []*ReturnRepositoryMockAddReturnParams{}

	m.ListReturnsMock = mReturnRepositoryMockListReturns{mock: m}
	m.ListReturnsMock.callArgs = []*ReturnRepositoryMockListReturnsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mReturnRepositoryMockAddReturn struct {
	optional           bool
	mock               *ReturnRepositoryMock
	defaultExpectation *ReturnRepositoryMockAddReturnExpectation
	expectations       []*ReturnRepositoryMockAddReturnExpectation

	callArgs []*ReturnRepositoryMockAddReturnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReturnRepositoryMockAddReturnExpectation specifies expectation struct of the ReturnRepository.AddReturn
type ReturnRepositoryMockAddReturnExpectation struct {
	mock               *ReturnRepositoryMock
	params             *ReturnRepositoryMockAddReturnParams
	paramPtrs          *ReturnRepositoryMockAddReturnParamPtrs
	expectationOrigins ReturnRepositoryMockAddReturnExpectationOrigins
	results            *ReturnRepositoryMockAddReturnResults
	returnOrigin       string
	Counter            uint64
}

// ReturnRepositoryMockAddReturnParams contains parameters of the ReturnRepository.AddReturn
type ReturnRepositoryMockAddReturnParams struct {
	ctx context.Context
	ret *domain.Return
}

// ReturnRepositoryMockAddReturnParamPtrs contains pointers to parameters of the ReturnRepository.AddReturn
type ReturnRepositoryMockAddReturnParamPtrs struct {
	ctx *context.Context
	ret **domain.Return
}

// ReturnRepositoryMockAddReturnResults contains results of the ReturnRepository.AddReturn
type ReturnRepositoryMockAddReturnResults struct {
	err error
}

// ReturnRepositoryMockAddReturnOrigins contains origins of expectations of the ReturnRepository.AddReturn
type ReturnRepositoryMockAddReturnExpectationOrigins struct {
	origin    string
	originCtx string
	originRet string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddReturn *mReturnRepositoryMockAddReturn) Optional() *mReturnRepositoryMockAddReturn {
	mmAddReturn.optional = true
	return mmAddReturn
}

// Expect sets up expected params for ReturnRepository.AddReturn
func (mmAddReturn *mReturnRepositoryMockAddReturn) Expect(ctx context.Context, ret *domain.Return) *mReturnRepositoryMockAddReturn {
	if mmAddReturn.mock.funcAddReturn != nil {
		mmAddReturn.mock.t.Fatalf("ReturnRepositoryMock.AddReturn mock is already set by Set")
	}

	if mmAddReturn.defaultExpectation == nil {
		mmAddReturn.defaultExpectation = &ReturnRepositoryMockAddReturnExpectation{}
	}

	if mmAddReturn.defaultExpectation.paramPtrs != nil {
		mmAddReturn.mock.t.Fatalf("ReturnRepositoryMock.AddReturn mock is already set by ExpectParams functions")
	}

	mmAddReturn.defaultExpectation.params = &ReturnRepositoryMockAddReturnParams{ctx, ret}
	mmAddReturn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddReturn.expectations {
		if minimock.Equal(e.params, mmAddReturn.defaultExpectation.params) {
			mmAddReturn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddReturn.defaultExpectation.params)
		}
	}

	return mmAddReturn
}

// ExpectCtxParam1 sets up expected param ctx for ReturnRepository.AddReturn
func (mmAddReturn *mReturnRepositoryMockAddReturn) ExpectCtxParam1(ctx context.Context) *mReturnRepositoryMockAddReturn {
	if mmAddReturn.mock.funcAddReturn != nil {
		mmAddReturn.mock.t.Fatalf("ReturnRepositoryMock.AddReturn mock is already set by Set")
	}

	if mmAddReturn.defaultExpectation == nil {
		mmAddReturn.defaultExpectation = &ReturnRepositoryMockAddReturnExpectation{}
	}

	if mmAddReturn.defaultExpectation.params != nil {
		mmAddReturn.mock.t.Fatalf("ReturnRepositoryMock.AddReturn mock is already set by Expect")
	}

	if mmAddReturn.defaultExpectation.paramPtrs == nil {
		mmAddReturn.defaultExpectation.paramPtrs = &ReturnRepositoryMockAddReturnParamPtrs{}
	}
	mmAddReturn.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddReturn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddReturn
}

// ExpectRetParam2 sets up expected param ret for ReturnRepository.AddReturn
func (mmAddReturn *mReturnRepositoryMockAddReturn) ExpectRetParam2(ret *domain.Return) *mReturnRepositoryMockAddReturn {
	if mmAddReturn.mock.funcAddReturn != nil {
		mmAddReturn.mock.t.Fatalf("ReturnRepositoryMock.AddReturn mock is already set by Set")
	}

	if mmAddReturn.defaultExpectation == nil {
		mmAddReturn.defaultExpectation = &ReturnRepositoryMockAddReturnExpectation{}
	}

	if mmAddReturn.defaultExpectation.params != nil {
		mmAddReturn.mock.t.Fatalf("ReturnRepositoryMock.AddReturn mock is already set by Expect")
	}

	if mmAddReturn.defaultExpectation.paramPtrs == nil {
		mmAddReturn.defaultExpectation.paramPtrs = &ReturnRepositoryMockAddReturnParamPtrs{}
	}
	mmAddReturn.defaultExpectation.paramPtrs.ret = &ret
	mmAddReturn.defaultExpectation.expectationOrigins.originRet = minimock.CallerInfo(1)

	return mmAddReturn
}

// Inspect accepts an inspector function that has same arguments as the ReturnRepository.AddReturn
func (mmAddReturn *mReturnRepositoryMockAddReturn) Inspect(f func(ctx context.Context, ret *domain.Return)) *mReturnRepositoryMockAddReturn {
	if mmAddReturn.mock.inspectFuncAddReturn != nil {
		mmAddReturn.mock.t.Fatalf("Inspect function is already set for ReturnRepositoryMock.AddReturn")
	}

	mmAddReturn.mock.inspectFuncAddReturn = f

	return mmAddReturn
}

// Return sets up results that will be returned by ReturnRepository.AddReturn
func (mmAddReturn *mReturnRepositoryMockAddReturn) Return(err error) *ReturnRepositoryMock {
	if mmAddReturn.mock.funcAddReturn != nil {
		mmAddReturn.mock.t.Fatalf("ReturnRepositoryMock.AddReturn mock is already set by Set")
	}

	if mmAddReturn.defaultExpectation == nil {
		mmAddReturn.defaultExpectation = &ReturnRepositoryMockAddReturnExpectation{mock: mmAddReturn.mock}
	}
	mmAddReturn.defaultExpectation.results = &ReturnRepositoryMockAddReturnResults{err}
	mmAddReturn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddReturn.mock
}

// Set uses given function f to mock the ReturnRepository.AddReturn method
func (mmAddReturn *mReturnRepositoryMockAddReturn) Set(f func(ctx context.Context, ret *domain.Return) (err error)) *ReturnRepositoryMock {
	if mmAddReturn.defaultExpectation != nil {
		mmAddReturn.mock.t.Fatalf("Default expectation is already set for the ReturnRepository.AddReturn method")
	}

	if len(mmAddReturn.expectations) > 0 {
		mmAddReturn.mock.t.Fatalf("Some expectations are already set for the ReturnRepository.AddReturn method")
	}

	mmAddReturn.mock.funcAddReturn = f
	mmAddReturn.mock.funcAddReturnOrigin = minimock.CallerInfo(1)
	return mmAddReturn.mock
}

// When sets expectation for the ReturnRepository.AddReturn which will trigger the result defined by the following
// Then helper
func (mmAddReturn *mReturnRepositoryMockAddReturn) When(ctx context.Context, ret *domain.Return) *ReturnRepositoryMockAddReturnExpectation {
	if mmAddReturn.mock.funcAddReturn != nil {
		mmAddReturn.mock.t.Fatalf("ReturnRepositoryMock.AddReturn mock is already set by Set")
	}

	expectation := &ReturnRepositoryMockAddReturnExpectation{
		mock:               mmAddReturn.mock,
		params:             &ReturnRepositoryMockAddReturnParams{ctx, ret},
		expectationOrigins: ReturnRepositoryMockAddReturnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddReturn.expectations = append(mmAddReturn.expectations, expectation)
	return expectation
}

// Then sets up ReturnRepository.AddReturn return parameters for the expectation previously defined by the When method
func (e *ReturnRepositoryMockAddReturnExpectation) Then(err error) *ReturnRepositoryMock {
	e.results = &ReturnRepositoryMockAddReturnResults{err}
	return e.mock
}

// Times sets number of times ReturnRepository.AddReturn should be invoked
func (mmAddReturn *mReturnRepositoryMockAddReturn) Times(n uint64) *mReturnRepositoryMockAddReturn {
	if n == 0 {
		mmAddReturn.mock.t.Fatalf("Times of ReturnRepositoryMock.AddReturn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddReturn.expectedInvocations, n)
	mmAddReturn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddReturn
}

func (mmAddReturn *mReturnRepositoryMockAddReturn) invocationsDone() bool {
	if len(mmAddReturn.expectations) == 0 && mmAddReturn.defaultExpectation == nil && mmAddReturn.mock.funcAddReturn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddReturn.mock.afterAddReturnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddReturn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddReturn implements mm_repository.ReturnRepository
func (mmAddReturn *ReturnRepositoryMock) AddReturn(ctx context.Context, ret *domain.Return) (err error) {
	mm_atomic.AddUint64(&mmAddReturn.beforeAddReturnCounter, 1)
	defer mm_atomic.AddUint64(&mmAddReturn.afterAddReturnCounter, 1)

	mmAddReturn.t.Helper()

	if mmAddReturn.inspectFuncAddReturn != nil {
		mmAddReturn.inspectFuncAddReturn(ctx, ret)
	}

	mm_params := ReturnRepositoryMockAddReturnParams{ctx, ret}

	// Record call args
	mmAddReturn.AddReturnMock.mutex.Lock()
	mmAddReturn.AddReturnMock.callArgs = append(mmAddReturn.AddReturnMock.callArgs, &mm_params)
	mmAddReturn.AddReturnMock.mutex.Unlock()

	for _, e := range mmAddReturn.AddReturnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddReturn.AddReturnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddReturn.AddReturnMock.defaultExpectation.Counter, 1)
		mm_want := mmAddReturn.AddReturnMock.defaultExpectation.params
		mm_want_ptrs := mmAddReturn.AddReturnMock.defaultExpectation.paramPtrs

		mm_got := ReturnRepositoryMockAddReturnParams{ctx, ret}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddReturn.t.Errorf("ReturnRepositoryMock.AddReturn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddReturn.AddReturnMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ret != nil && !minimock.Equal(*mm_want_ptrs.ret, mm_got.ret) {
				mmAddReturn.t.Errorf("ReturnRepositoryMock.AddReturn got unexpected parameter ret, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddReturn.AddReturnMock.defaultExpectation.expectationOrigins.originRet, *mm_want_ptrs.ret, mm_got.ret, minimock.Diff(*mm_want_ptrs.ret, mm_got.ret))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddReturn.t.Errorf("ReturnRepositoryMock.AddReturn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddReturn.AddReturnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddReturn.AddReturnMock.defaultExpectation.results
		if mm_results == nil {
			mmAddReturn.t.Fatal("No results are set for the ReturnRepositoryMock.AddReturn")
		}
		return (*mm_results).err
	}
	if mmAddReturn.funcAddReturn != nil {
		return mmAddReturn.funcAddReturn(ctx, ret)
	}
	mmAddReturn.t.Fatalf("Unexpected call to ReturnRepositoryMock.AddReturn. %v %v", ctx, ret)
	return
}

// AddReturnAfterCounter returns a count of finished ReturnRepositoryMock.AddReturn invocations
func (mmAddReturn *ReturnRepositoryMock) AddReturnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReturn.afterAddReturnCounter)
}

// AddReturnBeforeCounter returns a count of ReturnRepositoryMock.AddReturn invocations
func (mmAddReturn *ReturnRepositoryMock) AddReturnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddReturn.beforeAddReturnCounter)
}

// Calls returns a list of arguments used in each call to ReturnRepositoryMock.AddReturn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddReturn *mReturnRepositoryMockAddReturn) Calls() []*ReturnRepositoryMockAddReturnParams {
	mmAddReturn.mutex.RLock()

	argCopy := make([]*ReturnRepositoryMockAddReturnParams, len(mmAddReturn.callArgs))
	copy(argCopy, mmAddReturn.callArgs)

	mmAddReturn.mutex.RUnlock()

	return argCopy
}

// MinimockAddReturnDone returns true if the count of the AddReturn invocations corresponds
// the number of defined expectations
func (m *ReturnRepositoryMock) MinimockAddReturnDone() bool {
	if m.AddReturnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddReturnMock.invocationsDone()
}

// MinimockAddReturnInspect logs each unmet expectation
func (m *ReturnRepositoryMock) MinimockAddReturnInspect() {
	for _, e := range m.AddReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReturnRepositoryMock.AddReturn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddReturnCounter := mm_atomic.LoadUint64(&m.afterAddReturnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddReturnMock.defaultExpectation != nil && afterAddReturnCounter < 1 {
		if m.AddReturnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReturnRepositoryMock.AddReturn at\n%s", m.AddReturnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReturnRepositoryMock.AddReturn at\n%s with params: %#v", m.AddReturnMock.defaultExpectation.expectationOrigins.origin, *m.AddReturnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddReturn != nil && afterAddReturnCounter < 1 {
		m.t.Errorf("Expected call to ReturnRepositoryMock.AddReturn at\n%s", m.funcAddReturnOrigin)
	}

	if !m.AddReturnMock.invocationsDone() && afterAddReturnCounter > 0 {
		m.t.Errorf("Expected %d calls to ReturnRepositoryMock.AddReturn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddReturnMock.expectedInvocations), m.AddReturnMock.expectedInvocationsOrigin, afterAddReturnCounter)
	}
}

type mReturnRepositoryMockListReturns struct {
	optional           bool
	mock               *ReturnRepositoryMock
	defaultExpectation *ReturnRepositoryMockListReturnsExpectation
	expectations       []*ReturnRepositoryMockListReturnsExpectation

	callArgs []*ReturnRepositoryMockListReturnsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReturnRepositoryMockListReturnsExpectation specifies expectation struct of the ReturnRepository.ListReturns
type ReturnRepositoryMockListReturnsExpectation struct {
	mock               *ReturnRepositoryMock
	params             *ReturnRepositoryMockListReturnsParams
	paramPtrs          *ReturnRepositoryMockListReturnsParamPtrs
	expectationOrigins ReturnRepositoryMockListReturnsExpectationOrigins
	results            *ReturnRepositoryMockListReturnsResults
	returnOrigin       string
	Counter            uint64
}

// ReturnRepositoryMockListReturnsParams contains parameters of the ReturnRepository.ListReturns
type ReturnRepositoryMockListReturnsParams struct {
	ctx context.Context
}

// ReturnRepositoryMockListReturnsParamPtrs contains pointers to parameters of the ReturnRepository.ListReturns
type ReturnRepositoryMockListReturnsParamPtrs struct {
	ctx *context.Context
}

// ReturnRepositoryMockListReturnsResults contains results of the ReturnRepository.ListReturns
type ReturnRepositoryMockListReturnsResults struct {
	rpa1 []*domain.Return
	err  error
}

// ReturnRepositoryMockListReturnsOrigins contains origins of expectations of the ReturnRepository.ListReturns
type ReturnRepositoryMockListReturnsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListReturns *mReturnRepositoryMockListReturns) Optional() *mReturnRepositoryMockListReturns {
	mmListReturns.optional = true
	return mmListReturns
}

// Expect sets up expected params for ReturnRepository.ListReturns
func (mmListReturns *mReturnRepositoryMockListReturns) Expect(ctx context.Context) *mReturnRepositoryMockListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("ReturnRepositoryMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &ReturnRepositoryMockListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.paramPtrs != nil {
		mmListReturns.mock.t.Fatalf("ReturnRepositoryMock.ListReturns mock is already set by ExpectParams functions")
	}

	mmListReturns.defaultExpectation.params = &ReturnRepositoryMockListReturnsParams{ctx}
	mmListReturns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListReturns.expectations {
		if minimock.Equal(e.params, mmListReturns.defaultExpectation.params) {
			mmListReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListReturns.defaultExpectation.params)
		}
	}

	return mmListReturns
}

// ExpectCtxParam1 sets up expected param ctx for ReturnRepository.ListReturns
func (mmListReturns *mReturnRepositoryMockListReturns) ExpectCtxParam1(ctx context.Context) *mReturnRepositoryMockListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("ReturnRepositoryMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &ReturnRepositoryMockListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.params != nil {
		mmListReturns.mock.t.Fatalf("ReturnRepositoryMock.ListReturns mock is already set by Expect")
	}

	if mmListReturns.defaultExpectation.paramPtrs == nil {
		mmListReturns.defaultExpectation.paramPtrs = &ReturnRepositoryMockListReturnsParamPtrs{}
	}
	mmListReturns.defaultExpectation.paramPtrs.ctx = &ctx
	mmListReturns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListReturns
}

// Inspect accepts an inspector function that has same arguments as the ReturnRepository.ListReturns
func (mmListReturns *mReturnRepositoryMockListReturns) Inspect(f func(ctx context.Context)) *mReturnRepositoryMockListReturns {
	if mmListReturns.mock.inspectFuncListReturns != nil {
		mmListReturns.mock.t.Fatalf("Inspect function is already set for ReturnRepositoryMock.ListReturns")
	}

	mmListReturns.mock.inspectFuncListReturns = f

	return mmListReturns
}

// Return sets up results that will be returned by ReturnRepository.ListReturns
func (mmListReturns *mReturnRepositoryMockListReturns) Return(rpa1 []*domain.Return, err error) *ReturnRepositoryMock {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("ReturnRepositoryMock.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &ReturnRepositoryMockListReturnsExpectation{mock: mmListReturns.mock}
	}
	mmListReturns.defaultExpectation.results = &ReturnRepositoryMockListReturnsResults{rpa1, err}
	mmListReturns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListReturns.mock
}

// Set uses given function f to mock the ReturnRepository.ListReturns method
func (mmListReturns *mReturnRepositoryMockListReturns) Set(f func(ctx context.Context) (rpa1 []*domain.Return, err error)) *ReturnRepositoryMock {
	if mmListReturns.defaultExpectation != nil {
		mmListReturns.mock.t.Fatalf("Default expectation is already set for the ReturnRepository.ListReturns method")
	}

	if len(mmListReturns.expectations) > 0 {
		mmListReturns.mock.t.Fatalf("Some expectations are already set for the ReturnRepository.ListReturns method")
	}

	mmListReturns.mock.funcListReturns = f
	mmListReturns.mock.funcListReturnsOrigin = minimock.CallerInfo(1)
	return mmListReturns.mock
}

// When sets expectation for the ReturnRepository.ListReturns which will trigger the result defined by the following
// Then helper
func (mmListReturns *mReturnRepositoryMockListReturns) When(ctx context.Context) *ReturnRepositoryMockListReturnsExpectation {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("ReturnRepositoryMock.ListReturns mock is already set by Set")
	}

	expectation := &ReturnRepositoryMockListReturnsExpectation{
		mock:               mmListReturns.mock,
		params:             &ReturnRepositoryMockListReturnsParams{ctx},
		expectationOrigins: ReturnRepositoryMockListReturnsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListReturns.expectations = append(mmListReturns.expectations, expectation)
	return expectation
}

// Then sets up ReturnRepository.ListReturns return parameters for the expectation previously defined by the When method
func (e *ReturnRepositoryMockListReturnsExpectation) Then(rpa1 []*domain.Return, err error) *ReturnRepositoryMock {
	e.results = &ReturnRepositoryMockListReturnsResults{rpa1, err}
	return e.mock
}

// Times sets number of times ReturnRepository.ListReturns should be invoked
func (mmListReturns *mReturnRepositoryMockListReturns) Times(n uint64) *mReturnRepositoryMockListReturns {
	if n == 0 {
		mmListReturns.mock.t.Fatalf("Times of ReturnRepositoryMock.ListReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListReturns.expectedInvocations, n)
	mmListReturns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListReturns
}

func (mmListReturns *mReturnRepositoryMockListReturns) invocationsDone() bool {
	if len(mmListReturns.expectations) == 0 && mmListReturns.defaultExpectation == nil && mmListReturns.mock.funcListReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListReturns.mock.afterListReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListReturns implements mm_repository.ReturnRepository
func (mmListReturns *ReturnRepositoryMock) ListReturns(ctx context.Context) (rpa1 []*domain.Return, err error) {
	mm_atomic.AddUint64(&mmListReturns.beforeListReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmListReturns.afterListReturnsCounter, 1)

	mmListReturns.t.Helper()

	if mmListReturns.inspectFuncListReturns != nil {
		mmListReturns.inspectFuncListReturns(ctx)
	}

	mm_params := ReturnRepositoryMockListReturnsParams{ctx}

	// Record call args
	mmListReturns.ListReturnsMock.mutex.Lock()
	mmListReturns.ListReturnsMock.callArgs = append(mmListReturns.ListReturnsMock.callArgs, &mm_params)
	mmListReturns.ListReturnsMock.mutex.Unlock()

	for _, e := range mmListReturns.ListReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rpa1, e.results.err
		}
	}

	if mmListReturns.ListReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListReturns.ListReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmListReturns.ListReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmListReturns.ListReturnsMock.defaultExpectation.paramPtrs

		mm_got := ReturnRepositoryMockListReturnsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListReturns.t.Errorf("ReturnRepositoryMock.ListReturns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListReturns.t.Errorf("ReturnRepositoryMock.ListReturns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListReturns.ListReturnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListReturns.ListReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmListReturns.t.Fatal("No results are set for the ReturnRepositoryMock.ListReturns")
		}
		return (*mm_results).rpa1, (*mm_results).err
	}
	if mmListReturns.funcListReturns != nil {
		return mmListReturns.funcListReturns(ctx)
	}
	mmListReturns.t.Fatalf("Unexpected call to ReturnRepositoryMock.ListReturns. %v", ctx)
	return
}

// ListReturnsAfterCounter returns a count of finished ReturnRepositoryMock.ListReturns invocations
func (mmListReturns *ReturnRepositoryMock) ListReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturns.afterListReturnsCounter)
}

// ListReturnsBeforeCounter returns a count of ReturnRepositoryMock.ListReturns invocations
func (mmListReturns *ReturnRepositoryMock) ListReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturns.beforeListReturnsCounter)
}

// Calls returns a list of arguments used in each call to ReturnRepositoryMock.ListReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListReturns *mReturnRepositoryMockListReturns) Calls() []*ReturnRepositoryMockListReturnsParams {
	mmListReturns.mutex.RLock()

	argCopy := make([]*ReturnRepositoryMockListReturnsParams, len(mmListReturns.callArgs))
	copy(argCopy, mmListReturns.callArgs)

	mmListReturns.mutex.RUnlock()

	return argCopy
}

// MinimockListReturnsDone returns true if the count of the ListReturns invocations corresponds
// the number of defined expectations
func (m *ReturnRepositoryMock) MinimockListReturnsDone() bool {
	if m.ListReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListReturnsMock.invocationsDone()
}

// MinimockListReturnsInspect logs each unmet expectation
func (m *ReturnRepositoryMock) MinimockListReturnsInspect() {
	for _, e := range m.ListReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReturnRepositoryMock.ListReturns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListReturnsCounter := mm_atomic.LoadUint64(&m.afterListReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListReturnsMock.defaultExpectation != nil && afterListReturnsCounter < 1 {
		if m.ListReturnsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReturnRepositoryMock.ListReturns at\n%s", m.ListReturnsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReturnRepositoryMock.ListReturns at\n%s with params: %#v", m.ListReturnsMock.defaultExpectation.expectationOrigins.origin, *m.ListReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListReturns != nil && afterListReturnsCounter < 1 {
		m.t.Errorf("Expected call to ReturnRepositoryMock.ListReturns at\n%s", m.funcListReturnsOrigin)
	}

	if !m.ListReturnsMock.invocationsDone() && afterListReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to ReturnRepositoryMock.ListReturns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListReturnsMock.expectedInvocations), m.ListReturnsMock.expectedInvocationsOrigin, afterListReturnsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReturnRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddReturnInspect()

			m.MinimockListReturnsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReturnRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ReturnRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddReturnDone() &&
		m.MinimockListReturnsDone()
}
