// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

import (
	"context"
	"homework-1/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderRepositoryMock implements mm_repository.OrderRepository
type OrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddOrder          func(ctx context.Context, order *domain.Order) (err error)
	funcAddOrderOrigin    string
	inspectFuncAddOrder   func(ctx context.Context, order *domain.Order)
	afterAddOrderCounter  uint64
	beforeAddOrderCounter uint64
	AddOrderMock          mOrderRepositoryMockAddOrder

	funcDeleteOrder          func(ctx context.Context, orderID string) (err error)
	funcDeleteOrderOrigin    string
	inspectFuncDeleteOrder   func(ctx context.Context, orderID string)
	afterDeleteOrderCounter  uint64
	beforeDeleteOrderCounter uint64
	DeleteOrderMock          mOrderRepositoryMockDeleteOrder

	funcGetOrder          func(ctx context.Context, orderID string) (op1 *domain.Order, err error)
	funcGetOrderOrigin    string
	inspectFuncGetOrder   func(ctx context.Context, orderID string)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mOrderRepositoryMockGetOrder

	funcListOrders          func(ctx context.Context) (opa1 []*domain.Order, err error)
	funcListOrdersOrigin    string
	inspectFuncListOrders   func(ctx context.Context)
	afterListOrdersCounter  uint64
	beforeListOrdersCounter uint64
	ListOrdersMock          mOrderRepositoryMockListOrders

	funcUpdateOrder          func(ctx context.Context, order *domain.Order) (err error)
	funcUpdateOrderOrigin    string
	inspectFuncUpdateOrder   func(ctx context.Context, order *domain.Order)
	afterUpdateOrderCounter  uint64
	beforeUpdateOrderCounter uint64
	UpdateOrderMock          mOrderRepositoryMockUpdateOrder
}

// NewOrderRepositoryMock returns a mock for mm_repository.OrderRepository
func NewOrderRepositoryMock(t minimock.Tester) *OrderRepositoryMock {
	m := &OrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddOrderMock = mOrderRepositoryMockAddOrder{mock: m}
	m.AddOrderMock.callArgs = []*OrderRepositoryMockAddOrderParams{}

	m.DeleteOrderMock = mOrderRepositoryMockDeleteOrder{mock: m}
	m.DeleteOrderMock.callArgs = []*OrderRepositoryMockDeleteOrderParams{}

	m.GetOrderMock = mOrderRepositoryMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*OrderRepositoryMockGetOrderParams{}

	m.ListOrdersMock = mOrderRepositoryMockListOrders{mock: m}
	m.ListOrdersMock.callArgs = []*OrderRepositoryMockListOrdersParams{}

	m.UpdateOrderMock = mOrderRepositoryMockUpdateOrder{mock: m}
	m.UpdateOrderMock.callArgs = []*OrderRepositoryMockUpdateOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepositoryMockAddOrder struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockAddOrderExpectation
	expectations       []*OrderRepositoryMockAddOrderExpectation

	callArgs []*OrderRepositoryMockAddOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockAddOrderExpectation specifies expectation struct of the OrderRepository.AddOrder
type OrderRepositoryMockAddOrderExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockAddOrderParams
	paramPtrs          *OrderRepositoryMockAddOrderParamPtrs
	expectationOrigins OrderRepositoryMockAddOrderExpectationOrigins
	results            *OrderRepositoryMockAddOrderResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockAddOrderParams contains parameters of the OrderRepository.AddOrder
type OrderRepositoryMockAddOrderParams struct {
	ctx   context.Context
	order *domain.Order
}

// OrderRepositoryMockAddOrderParamPtrs contains pointers to parameters of the OrderRepository.AddOrder
type OrderRepositoryMockAddOrderParamPtrs struct {
	ctx   *context.Context
	order **domain.Order
}

// OrderRepositoryMockAddOrderResults contains results of the OrderRepository.AddOrder
type OrderRepositoryMockAddOrderResults struct {
	err error
}

// OrderRepositoryMockAddOrderOrigins contains origins of expectations of the OrderRepository.AddOrder
type OrderRepositoryMockAddOrderExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrder *mOrderRepositoryMockAddOrder) Optional() *mOrderRepositoryMockAddOrder {
	mmAddOrder.optional = true
	return mmAddOrder
}

// Expect sets up expected params for OrderRepository.AddOrder
func (mmAddOrder *mOrderRepositoryMockAddOrder) Expect(ctx context.Context, order *domain.Order) *mOrderRepositoryMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepositoryMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderRepositoryMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.paramPtrs != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepositoryMock.AddOrder mock is already set by ExpectParams functions")
	}

	mmAddOrder.defaultExpectation.params = &OrderRepositoryMockAddOrderParams{ctx, order}
	mmAddOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrder.expectations {
		if minimock.Equal(e.params, mmAddOrder.defaultExpectation.params) {
			mmAddOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrder.defaultExpectation.params)
		}
	}

	return mmAddOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.AddOrder
func (mmAddOrder *mOrderRepositoryMockAddOrder) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepositoryMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderRepositoryMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepositoryMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectOrderParam2 sets up expected param order for OrderRepository.AddOrder
func (mmAddOrder *mOrderRepositoryMockAddOrder) ExpectOrderParam2(order *domain.Order) *mOrderRepositoryMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepositoryMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderRepositoryMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepositoryMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.order = &order
	mmAddOrder.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmAddOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.AddOrder
func (mmAddOrder *mOrderRepositoryMockAddOrder) Inspect(f func(ctx context.Context, order *domain.Order)) *mOrderRepositoryMockAddOrder {
	if mmAddOrder.mock.inspectFuncAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.AddOrder")
	}

	mmAddOrder.mock.inspectFuncAddOrder = f

	return mmAddOrder
}

// Return sets up results that will be returned by OrderRepository.AddOrder
func (mmAddOrder *mOrderRepositoryMockAddOrder) Return(err error) *OrderRepositoryMock {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepositoryMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderRepositoryMockAddOrderExpectation{mock: mmAddOrder.mock}
	}
	mmAddOrder.defaultExpectation.results = &OrderRepositoryMockAddOrderResults{err}
	mmAddOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// Set uses given function f to mock the OrderRepository.AddOrder method
func (mmAddOrder *mOrderRepositoryMockAddOrder) Set(f func(ctx context.Context, order *domain.Order) (err error)) *OrderRepositoryMock {
	if mmAddOrder.defaultExpectation != nil {
		mmAddOrder.mock.t.Fatalf("Default expectation is already set for the OrderRepository.AddOrder method")
	}

	if len(mmAddOrder.expectations) > 0 {
		mmAddOrder.mock.t.Fatalf("Some expectations are already set for the OrderRepository.AddOrder method")
	}

	mmAddOrder.mock.funcAddOrder = f
	mmAddOrder.mock.funcAddOrderOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// When sets expectation for the OrderRepository.AddOrder which will trigger the result defined by the following
// Then helper
func (mmAddOrder *mOrderRepositoryMockAddOrder) When(ctx context.Context, order *domain.Order) *OrderRepositoryMockAddOrderExpectation {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepositoryMock.AddOrder mock is already set by Set")
	}

	expectation := &OrderRepositoryMockAddOrderExpectation{
		mock:               mmAddOrder.mock,
		params:             &OrderRepositoryMockAddOrderParams{ctx, order},
		expectationOrigins: OrderRepositoryMockAddOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOrder.expectations = append(mmAddOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.AddOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockAddOrderExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockAddOrderResults{err}
	return e.mock
}

// Times sets number of times OrderRepository.AddOrder should be invoked
func (mmAddOrder *mOrderRepositoryMockAddOrder) Times(n uint64) *mOrderRepositoryMockAddOrder {
	if n == 0 {
		mmAddOrder.mock.t.Fatalf("Times of OrderRepositoryMock.AddOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrder.expectedInvocations, n)
	mmAddOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrder
}

func (mmAddOrder *mOrderRepositoryMockAddOrder) invocationsDone() bool {
	if len(mmAddOrder.expectations) == 0 && mmAddOrder.defaultExpectation == nil && mmAddOrder.mock.funcAddOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrder.mock.afterAddOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrder implements mm_repository.OrderRepository
func (mmAddOrder *OrderRepositoryMock) AddOrder(ctx context.Context, order *domain.Order) (err error) {
	mm_atomic.AddUint64(&mmAddOrder.beforeAddOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrder.afterAddOrderCounter, 1)

	mmAddOrder.t.Helper()

	if mmAddOrder.inspectFuncAddOrder != nil {
		mmAddOrder.inspectFuncAddOrder(ctx, order)
	}

	mm_params := OrderRepositoryMockAddOrderParams{ctx, order}

	// Record call args
	mmAddOrder.AddOrderMock.mutex.Lock()
	mmAddOrder.AddOrderMock.callArgs = append(mmAddOrder.AddOrderMock.callArgs, &mm_params)
	mmAddOrder.AddOrderMock.mutex.Unlock()

	for _, e := range mmAddOrder.AddOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOrder.AddOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrder.AddOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrder.AddOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrder.AddOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockAddOrderParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddOrder.t.Errorf("OrderRepositoryMock.AddOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmAddOrder.t.Errorf("OrderRepositoryMock.AddOrder got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrder.t.Errorf("OrderRepositoryMock.AddOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrder.AddOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrder.t.Fatal("No results are set for the OrderRepositoryMock.AddOrder")
		}
		return (*mm_results).err
	}
	if mmAddOrder.funcAddOrder != nil {
		return mmAddOrder.funcAddOrder(ctx, order)
	}
	mmAddOrder.t.Fatalf("Unexpected call to OrderRepositoryMock.AddOrder. %v %v", ctx, order)
	return
}

// AddOrderAfterCounter returns a count of finished OrderRepositoryMock.AddOrder invocations
func (mmAddOrder *OrderRepositoryMock) AddOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.afterAddOrderCounter)
}

// AddOrderBeforeCounter returns a count of OrderRepositoryMock.AddOrder invocations
func (mmAddOrder *OrderRepositoryMock) AddOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.beforeAddOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.AddOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrder *mOrderRepositoryMockAddOrder) Calls() []*OrderRepositoryMockAddOrderParams {
	mmAddOrder.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockAddOrderParams, len(mmAddOrder.callArgs))
	copy(argCopy, mmAddOrder.callArgs)

	mmAddOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderDone returns true if the count of the AddOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockAddOrderDone() bool {
	if m.AddOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderMock.invocationsDone()
}

// MinimockAddOrderInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockAddOrderInspect() {
	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.AddOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrderCounter := mm_atomic.LoadUint64(&m.afterAddOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderMock.defaultExpectation != nil && afterAddOrderCounter < 1 {
		if m.AddOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.AddOrder at\n%s", m.AddOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.AddOrder at\n%s with params: %#v", m.AddOrderMock.defaultExpectation.expectationOrigins.origin, *m.AddOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrder != nil && afterAddOrderCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.AddOrder at\n%s", m.funcAddOrderOrigin)
	}

	if !m.AddOrderMock.invocationsDone() && afterAddOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.AddOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderMock.expectedInvocations), m.AddOrderMock.expectedInvocationsOrigin, afterAddOrderCounter)
	}
}

type mOrderRepositoryMockDeleteOrder struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockDeleteOrderExpectation
	expectations       []*OrderRepositoryMockDeleteOrderExpectation

	callArgs []*OrderRepositoryMockDeleteOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockDeleteOrderExpectation specifies expectation struct of the OrderRepository.DeleteOrder
type OrderRepositoryMockDeleteOrderExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockDeleteOrderParams
	paramPtrs          *OrderRepositoryMockDeleteOrderParamPtrs
	expectationOrigins OrderRepositoryMockDeleteOrderExpectationOrigins
	results            *OrderRepositoryMockDeleteOrderResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockDeleteOrderParams contains parameters of the OrderRepository.DeleteOrder
type OrderRepositoryMockDeleteOrderParams struct {
	ctx     context.Context
	orderID string
}

// OrderRepositoryMockDeleteOrderParamPtrs contains pointers to parameters of the OrderRepository.DeleteOrder
type OrderRepositoryMockDeleteOrderParamPtrs struct {
	ctx     *context.Context
	orderID *string
}

// OrderRepositoryMockDeleteOrderResults contains results of the OrderRepository.DeleteOrder
type OrderRepositoryMockDeleteOrderResults struct {
	err error
}

// OrderRepositoryMockDeleteOrderOrigins contains origins of expectations of the OrderRepository.DeleteOrder
type OrderRepositoryMockDeleteOrderExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteOrder *mOrderRepositoryMockDeleteOrder) Optional() *mOrderRepositoryMockDeleteOrder {
	mmDeleteOrder.optional = true
	return mmDeleteOrder
}

// Expect sets up expected params for OrderRepository.DeleteOrder
func (mmDeleteOrder *mOrderRepositoryMockDeleteOrder) Expect(ctx context.Context, orderID string) *mOrderRepositoryMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("OrderRepositoryMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &OrderRepositoryMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs != nil {
		mmDeleteOrder.mock.t.Fatalf("OrderRepositoryMock.DeleteOrder mock is already set by ExpectParams functions")
	}

	mmDeleteOrder.defaultExpectation.params = &OrderRepositoryMockDeleteOrderParams{ctx, orderID}
	mmDeleteOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteOrder.expectations {
		if minimock.Equal(e.params, mmDeleteOrder.defaultExpectation.params) {
			mmDeleteOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrder.defaultExpectation.params)
		}
	}

	return mmDeleteOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.DeleteOrder
func (mmDeleteOrder *mOrderRepositoryMockDeleteOrder) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("OrderRepositoryMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &OrderRepositoryMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("OrderRepositoryMock.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderRepository.DeleteOrder
func (mmDeleteOrder *mOrderRepositoryMockDeleteOrder) ExpectOrderIDParam2(orderID string) *mOrderRepositoryMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("OrderRepositoryMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &OrderRepositoryMockDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("OrderRepositoryMock.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmDeleteOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmDeleteOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.DeleteOrder
func (mmDeleteOrder *mOrderRepositoryMockDeleteOrder) Inspect(f func(ctx context.Context, orderID string)) *mOrderRepositoryMockDeleteOrder {
	if mmDeleteOrder.mock.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.DeleteOrder")
	}

	mmDeleteOrder.mock.inspectFuncDeleteOrder = f

	return mmDeleteOrder
}

// Return sets up results that will be returned by OrderRepository.DeleteOrder
func (mmDeleteOrder *mOrderRepositoryMockDeleteOrder) Return(err error) *OrderRepositoryMock {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("OrderRepositoryMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &OrderRepositoryMockDeleteOrderExpectation{mock: mmDeleteOrder.mock}
	}
	mmDeleteOrder.defaultExpectation.results = &OrderRepositoryMockDeleteOrderResults{err}
	mmDeleteOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder.mock
}

// Set uses given function f to mock the OrderRepository.DeleteOrder method
func (mmDeleteOrder *mOrderRepositoryMockDeleteOrder) Set(f func(ctx context.Context, orderID string) (err error)) *OrderRepositoryMock {
	if mmDeleteOrder.defaultExpectation != nil {
		mmDeleteOrder.mock.t.Fatalf("Default expectation is already set for the OrderRepository.DeleteOrder method")
	}

	if len(mmDeleteOrder.expectations) > 0 {
		mmDeleteOrder.mock.t.Fatalf("Some expectations are already set for the OrderRepository.DeleteOrder method")
	}

	mmDeleteOrder.mock.funcDeleteOrder = f
	mmDeleteOrder.mock.funcDeleteOrderOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder.mock
}

// When sets expectation for the OrderRepository.DeleteOrder which will trigger the result defined by the following
// Then helper
func (mmDeleteOrder *mOrderRepositoryMockDeleteOrder) When(ctx context.Context, orderID string) *OrderRepositoryMockDeleteOrderExpectation {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("OrderRepositoryMock.DeleteOrder mock is already set by Set")
	}

	expectation := &OrderRepositoryMockDeleteOrderExpectation{
		mock:               mmDeleteOrder.mock,
		params:             &OrderRepositoryMockDeleteOrderParams{ctx, orderID},
		expectationOrigins: OrderRepositoryMockDeleteOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteOrder.expectations = append(mmDeleteOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.DeleteOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockDeleteOrderExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockDeleteOrderResults{err}
	return e.mock
}

// Times sets number of times OrderRepository.DeleteOrder should be invoked
func (mmDeleteOrder *mOrderRepositoryMockDeleteOrder) Times(n uint64) *mOrderRepositoryMockDeleteOrder {
	if n == 0 {
		mmDeleteOrder.mock.t.Fatalf("Times of OrderRepositoryMock.DeleteOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteOrder.expectedInvocations, n)
	mmDeleteOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteOrder
}

func (mmDeleteOrder *mOrderRepositoryMockDeleteOrder) invocationsDone() bool {
	if len(mmDeleteOrder.expectations) == 0 && mmDeleteOrder.defaultExpectation == nil && mmDeleteOrder.mock.funcDeleteOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteOrder.mock.afterDeleteOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteOrder implements mm_repository.OrderRepository
func (mmDeleteOrder *OrderRepositoryMock) DeleteOrder(ctx context.Context, orderID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteOrder.beforeDeleteOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrder.afterDeleteOrderCounter, 1)

	mmDeleteOrder.t.Helper()

	if mmDeleteOrder.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.inspectFuncDeleteOrder(ctx, orderID)
	}

	mm_params := OrderRepositoryMockDeleteOrderParams{ctx, orderID}

	// Record call args
	mmDeleteOrder.DeleteOrderMock.mutex.Lock()
	mmDeleteOrder.DeleteOrderMock.callArgs = append(mmDeleteOrder.DeleteOrderMock.callArgs, &mm_params)
	mmDeleteOrder.DeleteOrderMock.mutex.Unlock()

	for _, e := range mmDeleteOrder.DeleteOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteOrder.DeleteOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrder.DeleteOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrder.DeleteOrderMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteOrder.DeleteOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockDeleteOrderParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteOrder.t.Errorf("OrderRepositoryMock.DeleteOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmDeleteOrder.t.Errorf("OrderRepositoryMock.DeleteOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrder.t.Errorf("OrderRepositoryMock.DeleteOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteOrder.DeleteOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrder.DeleteOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrder.t.Fatal("No results are set for the OrderRepositoryMock.DeleteOrder")
		}
		return (*mm_results).err
	}
	if mmDeleteOrder.funcDeleteOrder != nil {
		return mmDeleteOrder.funcDeleteOrder(ctx, orderID)
	}
	mmDeleteOrder.t.Fatalf("Unexpected call to OrderRepositoryMock.DeleteOrder. %v %v", ctx, orderID)
	return
}

// DeleteOrderAfterCounter returns a count of finished OrderRepositoryMock.DeleteOrder invocations
func (mmDeleteOrder *OrderRepositoryMock) DeleteOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.afterDeleteOrderCounter)
}

// DeleteOrderBeforeCounter returns a count of OrderRepositoryMock.DeleteOrder invocations
func (mmDeleteOrder *OrderRepositoryMock) DeleteOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.beforeDeleteOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.DeleteOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrder *mOrderRepositoryMockDeleteOrder) Calls() []*OrderRepositoryMockDeleteOrderParams {
	mmDeleteOrder.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockDeleteOrderParams, len(mmDeleteOrder.callArgs))
	copy(argCopy, mmDeleteOrder.callArgs)

	mmDeleteOrder.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrderDone returns true if the count of the DeleteOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockDeleteOrderDone() bool {
	if m.DeleteOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteOrderMock.invocationsDone()
}

// MinimockDeleteOrderInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockDeleteOrderInspect() {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.DeleteOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteOrderCounter := mm_atomic.LoadUint64(&m.afterDeleteOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && afterDeleteOrderCounter < 1 {
		if m.DeleteOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.DeleteOrder at\n%s", m.DeleteOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.DeleteOrder at\n%s with params: %#v", m.DeleteOrderMock.defaultExpectation.expectationOrigins.origin, *m.DeleteOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && afterDeleteOrderCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.DeleteOrder at\n%s", m.funcDeleteOrderOrigin)
	}

	if !m.DeleteOrderMock.invocationsDone() && afterDeleteOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.DeleteOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteOrderMock.expectedInvocations), m.DeleteOrderMock.expectedInvocationsOrigin, afterDeleteOrderCounter)
	}
}

type mOrderRepositoryMockGetOrder struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetOrderExpectation
	expectations       []*OrderRepositoryMockGetOrderExpectation

	callArgs []*OrderRepositoryMockGetOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetOrderExpectation specifies expectation struct of the OrderRepository.GetOrder
type OrderRepositoryMockGetOrderExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetOrderParams
	paramPtrs          *OrderRepositoryMockGetOrderParamPtrs
	expectationOrigins OrderRepositoryMockGetOrderExpectationOrigins
	results            *OrderRepositoryMockGetOrderResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetOrderParams contains parameters of the OrderRepository.GetOrder
type OrderRepositoryMockGetOrderParams struct {
	ctx     context.Context
	orderID string
}

// OrderRepositoryMockGetOrderParamPtrs contains pointers to parameters of the OrderRepository.GetOrder
type OrderRepositoryMockGetOrderParamPtrs struct {
	ctx     *context.Context
	orderID *string
}

// OrderRepositoryMockGetOrderResults contains results of the OrderRepository.GetOrder
type OrderRepositoryMockGetOrderResults struct {
	op1 *domain.Order
	err error
}

// OrderRepositoryMockGetOrderOrigins contains origins of expectations of the OrderRepository.GetOrder
type OrderRepositoryMockGetOrderExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mOrderRepositoryMockGetOrder) Optional() *mOrderRepositoryMockGetOrder {
	mmGetOrder.optional = true
	return mmGetOrder
}

// Expect sets up expected params for OrderRepository.GetOrder
func (mmGetOrder *mOrderRepositoryMockGetOrder) Expect(ctx context.Context, orderID string) *mOrderRepositoryMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderRepositoryMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.paramPtrs != nil {
		mmGetOrder.mock.t.Fatalf("OrderRepositoryMock.GetOrder mock is already set by ExpectParams functions")
	}

	mmGetOrder.defaultExpectation.params = &OrderRepositoryMockGetOrderParams{ctx, orderID}
	mmGetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.GetOrder
func (mmGetOrder *mOrderRepositoryMockGetOrder) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderRepositoryMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("OrderRepositoryMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderRepository.GetOrder
func (mmGetOrder *mOrderRepositoryMockGetOrder) ExpectOrderIDParam2(orderID string) *mOrderRepositoryMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderRepositoryMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("OrderRepositoryMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.GetOrder
func (mmGetOrder *mOrderRepositoryMockGetOrder) Inspect(f func(ctx context.Context, orderID string)) *mOrderRepositoryMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by OrderRepository.GetOrder
func (mmGetOrder *mOrderRepositoryMockGetOrder) Return(op1 *domain.Order, err error) *OrderRepositoryMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderRepositoryMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &OrderRepositoryMockGetOrderResults{op1, err}
	mmGetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// Set uses given function f to mock the OrderRepository.GetOrder method
func (mmGetOrder *mOrderRepositoryMockGetOrder) Set(f func(ctx context.Context, orderID string) (op1 *domain.Order, err error)) *OrderRepositoryMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the OrderRepository.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the OrderRepository.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	mmGetOrder.mock.funcGetOrderOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// When sets expectation for the OrderRepository.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mOrderRepositoryMockGetOrder) When(ctx context.Context, orderID string) *OrderRepositoryMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderRepositoryMock.GetOrder mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetOrderExpectation{
		mock:               mmGetOrder.mock,
		params:             &OrderRepositoryMockGetOrderParams{ctx, orderID},
		expectationOrigins: OrderRepositoryMockGetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.GetOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetOrderExpectation) Then(op1 *domain.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetOrderResults{op1, err}
	return e.mock
}

// Times sets number of times OrderRepository.GetOrder should be invoked
func (mmGetOrder *mOrderRepositoryMockGetOrder) Times(n uint64) *mOrderRepositoryMockGetOrder {
	if n == 0 {
		mmGetOrder.mock.t.Fatalf("Times of OrderRepositoryMock.GetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrder.expectedInvocations, n)
	mmGetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrder
}

func (mmGetOrder *mOrderRepositoryMockGetOrder) invocationsDone() bool {
	if len(mmGetOrder.expectations) == 0 && mmGetOrder.defaultExpectation == nil && mmGetOrder.mock.funcGetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrder.mock.afterGetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrder implements mm_repository.OrderRepository
func (mmGetOrder *OrderRepositoryMock) GetOrder(ctx context.Context, orderID string) (op1 *domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	mmGetOrder.t.Helper()

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(ctx, orderID)
	}

	mm_params := OrderRepositoryMockGetOrderParams{ctx, orderID}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetOrderParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrder.t.Errorf("OrderRepositoryMock.GetOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetOrder.t.Errorf("OrderRepositoryMock.GetOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("OrderRepositoryMock.GetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the OrderRepositoryMock.GetOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(ctx, orderID)
	}
	mmGetOrder.t.Fatalf("Unexpected call to OrderRepositoryMock.GetOrder. %v %v", ctx, orderID)
	return
}

// GetOrderAfterCounter returns a count of finished OrderRepositoryMock.GetOrder invocations
func (mmGetOrder *OrderRepositoryMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of OrderRepositoryMock.GetOrder invocations
func (mmGetOrder *OrderRepositoryMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mOrderRepositoryMockGetOrder) Calls() []*OrderRepositoryMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetOrderDone() bool {
	if m.GetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderMock.invocationsDone()
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderCounter := mm_atomic.LoadUint64(&m.afterGetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && afterGetOrderCounter < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetOrder at\n%s", m.GetOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetOrder at\n%s with params: %#v", m.GetOrderMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && afterGetOrderCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.GetOrder at\n%s", m.funcGetOrderOrigin)
	}

	if !m.GetOrderMock.invocationsDone() && afterGetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderMock.expectedInvocations), m.GetOrderMock.expectedInvocationsOrigin, afterGetOrderCounter)
	}
}

type mOrderRepositoryMockListOrders struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockListOrdersExpectation
	expectations       []*OrderRepositoryMockListOrdersExpectation

	callArgs []*OrderRepositoryMockListOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockListOrdersExpectation specifies expectation struct of the OrderRepository.ListOrders
type OrderRepositoryMockListOrdersExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockListOrdersParams
	paramPtrs          *OrderRepositoryMockListOrdersParamPtrs
	expectationOrigins OrderRepositoryMockListOrdersExpectationOrigins
	results            *OrderRepositoryMockListOrdersResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockListOrdersParams contains parameters of the OrderRepository.ListOrders
type OrderRepositoryMockListOrdersParams struct {
	ctx context.Context
}

// OrderRepositoryMockListOrdersParamPtrs contains pointers to parameters of the OrderRepository.ListOrders
type OrderRepositoryMockListOrdersParamPtrs struct {
	ctx *context.Context
}

// OrderRepositoryMockListOrdersResults contains results of the OrderRepository.ListOrders
type OrderRepositoryMockListOrdersResults struct {
	opa1 []*domain.Order
	err  error
}

// OrderRepositoryMockListOrdersOrigins contains origins of expectations of the OrderRepository.ListOrders
type OrderRepositoryMockListOrdersExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListOrders *mOrderRepositoryMockListOrders) Optional() *mOrderRepositoryMockListOrders {
	mmListOrders.optional = true
	return mmListOrders
}

// Expect sets up expected params for OrderRepository.ListOrders
func (mmListOrders *mOrderRepositoryMockListOrders) Expect(ctx context.Context) *mOrderRepositoryMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("OrderRepositoryMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &OrderRepositoryMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.paramPtrs != nil {
		mmListOrders.mock.t.Fatalf("OrderRepositoryMock.ListOrders mock is already set by ExpectParams functions")
	}

	mmListOrders.defaultExpectation.params = &OrderRepositoryMockListOrdersParams{ctx}
	mmListOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListOrders.expectations {
		if minimock.Equal(e.params, mmListOrders.defaultExpectation.params) {
			mmListOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrders.defaultExpectation.params)
		}
	}

	return mmListOrders
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.ListOrders
func (mmListOrders *mOrderRepositoryMockListOrders) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("OrderRepositoryMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &OrderRepositoryMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.params != nil {
		mmListOrders.mock.t.Fatalf("OrderRepositoryMock.ListOrders mock is already set by Expect")
	}

	if mmListOrders.defaultExpectation.paramPtrs == nil {
		mmListOrders.defaultExpectation.paramPtrs = &OrderRepositoryMockListOrdersParamPtrs{}
	}
	mmListOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmListOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListOrders
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.ListOrders
func (mmListOrders *mOrderRepositoryMockListOrders) Inspect(f func(ctx context.Context)) *mOrderRepositoryMockListOrders {
	if mmListOrders.mock.inspectFuncListOrders != nil {
		mmListOrders.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.ListOrders")
	}

	mmListOrders.mock.inspectFuncListOrders = f

	return mmListOrders
}

// Return sets up results that will be returned by OrderRepository.ListOrders
func (mmListOrders *mOrderRepositoryMockListOrders) Return(opa1 []*domain.Order, err error) *OrderRepositoryMock {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("OrderRepositoryMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &OrderRepositoryMockListOrdersExpectation{mock: mmListOrders.mock}
	}
	mmListOrders.defaultExpectation.results = &OrderRepositoryMockListOrdersResults{opa1, err}
	mmListOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListOrders.mock
}

// Set uses given function f to mock the OrderRepository.ListOrders method
func (mmListOrders *mOrderRepositoryMockListOrders) Set(f func(ctx context.Context) (opa1 []*domain.Order, err error)) *OrderRepositoryMock {
	if mmListOrders.defaultExpectation != nil {
		mmListOrders.mock.t.Fatalf("Default expectation is already set for the OrderRepository.ListOrders method")
	}

	if len(mmListOrders.expectations) > 0 {
		mmListOrders.mock.t.Fatalf("Some expectations are already set for the OrderRepository.ListOrders method")
	}

	mmListOrders.mock.funcListOrders = f
	mmListOrders.mock.funcListOrdersOrigin = minimock.CallerInfo(1)
	return mmListOrders.mock
}

// When sets expectation for the OrderRepository.ListOrders which will trigger the result defined by the following
// Then helper
func (mmListOrders *mOrderRepositoryMockListOrders) When(ctx context.Context) *OrderRepositoryMockListOrdersExpectation {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("OrderRepositoryMock.ListOrders mock is already set by Set")
	}

	expectation := &OrderRepositoryMockListOrdersExpectation{
		mock:               mmListOrders.mock,
		params:             &OrderRepositoryMockListOrdersParams{ctx},
		expectationOrigins: OrderRepositoryMockListOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListOrders.expectations = append(mmListOrders.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.ListOrders return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockListOrdersExpectation) Then(opa1 []*domain.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockListOrdersResults{opa1, err}
	return e.mock
}

// Times sets number of times OrderRepository.ListOrders should be invoked
func (mmListOrders *mOrderRepositoryMockListOrders) Times(n uint64) *mOrderRepositoryMockListOrders {
	if n == 0 {
		mmListOrders.mock.t.Fatalf("Times of OrderRepositoryMock.ListOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListOrders.expectedInvocations, n)
	mmListOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListOrders
}

func (mmListOrders *mOrderRepositoryMockListOrders) invocationsDone() bool {
	if len(mmListOrders.expectations) == 0 && mmListOrders.defaultExpectation == nil && mmListOrders.mock.funcListOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListOrders.mock.afterListOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListOrders implements mm_repository.OrderRepository
func (mmListOrders *OrderRepositoryMock) ListOrders(ctx context.Context) (opa1 []*domain.Order, err error) {
	mm_atomic.AddUint64(&mmListOrders.beforeListOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrders.afterListOrdersCounter, 1)

	mmListOrders.t.Helper()

	if mmListOrders.inspectFuncListOrders != nil {
		mmListOrders.inspectFuncListOrders(ctx)
	}

	mm_params := OrderRepositoryMockListOrdersParams{ctx}

	// Record call args
	mmListOrders.ListOrdersMock.mutex.Lock()
	mmListOrders.ListOrdersMock.callArgs = append(mmListOrders.ListOrdersMock.callArgs, &mm_params)
	mmListOrders.ListOrdersMock.mutex.Unlock()

	for _, e := range mmListOrders.ListOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.opa1, e.results.err
		}
	}

	if mmListOrders.ListOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrders.ListOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrders.ListOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmListOrders.ListOrdersMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockListOrdersParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListOrders.t.Errorf("OrderRepositoryMock.ListOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrders.t.Errorf("OrderRepositoryMock.ListOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrders.ListOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrders.t.Fatal("No results are set for the OrderRepositoryMock.ListOrders")
		}
		return (*mm_results).opa1, (*mm_results).err
	}
	if mmListOrders.funcListOrders != nil {
		return mmListOrders.funcListOrders(ctx)
	}
	mmListOrders.t.Fatalf("Unexpected call to OrderRepositoryMock.ListOrders. %v", ctx)
	return
}

// ListOrdersAfterCounter returns a count of finished OrderRepositoryMock.ListOrders invocations
func (mmListOrders *OrderRepositoryMock) ListOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.afterListOrdersCounter)
}

// ListOrdersBeforeCounter returns a count of OrderRepositoryMock.ListOrders invocations
func (mmListOrders *OrderRepositoryMock) ListOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.beforeListOrdersCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.ListOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrders *mOrderRepositoryMockListOrders) Calls() []*OrderRepositoryMockListOrdersParams {
	mmListOrders.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockListOrdersParams, len(mmListOrders.callArgs))
	copy(argCopy, mmListOrders.callArgs)

	mmListOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListOrdersDone returns true if the count of the ListOrders invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockListOrdersDone() bool {
	if m.ListOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListOrdersMock.invocationsDone()
}

// MinimockListOrdersInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockListOrdersInspect() {
	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.ListOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListOrdersCounter := mm_atomic.LoadUint64(&m.afterListOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrdersMock.defaultExpectation != nil && afterListOrdersCounter < 1 {
		if m.ListOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.ListOrders at\n%s", m.ListOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.ListOrders at\n%s with params: %#v", m.ListOrdersMock.defaultExpectation.expectationOrigins.origin, *m.ListOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrders != nil && afterListOrdersCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.ListOrders at\n%s", m.funcListOrdersOrigin)
	}

	if !m.ListOrdersMock.invocationsDone() && afterListOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.ListOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListOrdersMock.expectedInvocations), m.ListOrdersMock.expectedInvocationsOrigin, afterListOrdersCounter)
	}
}

type mOrderRepositoryMockUpdateOrder struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockUpdateOrderExpectation
	expectations       []*OrderRepositoryMockUpdateOrderExpectation

	callArgs []*OrderRepositoryMockUpdateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockUpdateOrderExpectation specifies expectation struct of the OrderRepository.UpdateOrder
type OrderRepositoryMockUpdateOrderExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockUpdateOrderParams
	paramPtrs          *OrderRepositoryMockUpdateOrderParamPtrs
	expectationOrigins OrderRepositoryMockUpdateOrderExpectationOrigins
	results            *OrderRepositoryMockUpdateOrderResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockUpdateOrderParams contains parameters of the OrderRepository.UpdateOrder
type OrderRepositoryMockUpdateOrderParams struct {
	ctx   context.Context
	order *domain.Order
}

// OrderRepositoryMockUpdateOrderParamPtrs contains pointers to parameters of the OrderRepository.UpdateOrder
type OrderRepositoryMockUpdateOrderParamPtrs struct {
	ctx   *context.Context
	order **domain.Order
}

// OrderRepositoryMockUpdateOrderResults contains results of the OrderRepository.UpdateOrder
type OrderRepositoryMockUpdateOrderResults struct {
	err error
}

// OrderRepositoryMockUpdateOrderOrigins contains origins of expectations of the OrderRepository.UpdateOrder
type OrderRepositoryMockUpdateOrderExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Optional() *mOrderRepositoryMockUpdateOrder {
	mmUpdateOrder.optional = true
	return mmUpdateOrder
}

// Expect sets up expected params for OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Expect(ctx context.Context, order *domain.Order) *mOrderRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepositoryMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by ExpectParams functions")
	}

	mmUpdateOrder.defaultExpectation.params = &OrderRepositoryMockUpdateOrderParams{ctx, order}
	mmUpdateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateOrder.expectations {
		if minimock.Equal(e.params, mmUpdateOrder.defaultExpectation.params) {
			mmUpdateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrder.defaultExpectation.params)
		}
	}

	return mmUpdateOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepositoryMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.params != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Expect")
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs == nil {
		mmUpdateOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockUpdateOrderParamPtrs{}
	}
	mmUpdateOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateOrder
}

// ExpectOrderParam2 sets up expected param order for OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) ExpectOrderParam2(order *domain.Order) *mOrderRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepositoryMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.params != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Expect")
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs == nil {
		mmUpdateOrder.defaultExpectation.paramPtrs = &OrderRepositoryMockUpdateOrderParamPtrs{}
	}
	mmUpdateOrder.defaultExpectation.paramPtrs.order = &order
	mmUpdateOrder.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmUpdateOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Inspect(f func(ctx context.Context, order *domain.Order)) *mOrderRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.UpdateOrder")
	}

	mmUpdateOrder.mock.inspectFuncUpdateOrder = f

	return mmUpdateOrder
}

// Return sets up results that will be returned by OrderRepository.UpdateOrder
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Return(err error) *OrderRepositoryMock {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepositoryMockUpdateOrderExpectation{mock: mmUpdateOrder.mock}
	}
	mmUpdateOrder.defaultExpectation.results = &OrderRepositoryMockUpdateOrderResults{err}
	mmUpdateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateOrder.mock
}

// Set uses given function f to mock the OrderRepository.UpdateOrder method
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Set(f func(ctx context.Context, order *domain.Order) (err error)) *OrderRepositoryMock {
	if mmUpdateOrder.defaultExpectation != nil {
		mmUpdateOrder.mock.t.Fatalf("Default expectation is already set for the OrderRepository.UpdateOrder method")
	}

	if len(mmUpdateOrder.expectations) > 0 {
		mmUpdateOrder.mock.t.Fatalf("Some expectations are already set for the OrderRepository.UpdateOrder method")
	}

	mmUpdateOrder.mock.funcUpdateOrder = f
	mmUpdateOrder.mock.funcUpdateOrderOrigin = minimock.CallerInfo(1)
	return mmUpdateOrder.mock
}

// When sets expectation for the OrderRepository.UpdateOrder which will trigger the result defined by the following
// Then helper
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) When(ctx context.Context, order *domain.Order) *OrderRepositoryMockUpdateOrderExpectation {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepositoryMock.UpdateOrder mock is already set by Set")
	}

	expectation := &OrderRepositoryMockUpdateOrderExpectation{
		mock:               mmUpdateOrder.mock,
		params:             &OrderRepositoryMockUpdateOrderParams{ctx, order},
		expectationOrigins: OrderRepositoryMockUpdateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateOrder.expectations = append(mmUpdateOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderRepository.UpdateOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockUpdateOrderExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockUpdateOrderResults{err}
	return e.mock
}

// Times sets number of times OrderRepository.UpdateOrder should be invoked
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Times(n uint64) *mOrderRepositoryMockUpdateOrder {
	if n == 0 {
		mmUpdateOrder.mock.t.Fatalf("Times of OrderRepositoryMock.UpdateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateOrder.expectedInvocations, n)
	mmUpdateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateOrder
}

func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) invocationsDone() bool {
	if len(mmUpdateOrder.expectations) == 0 && mmUpdateOrder.defaultExpectation == nil && mmUpdateOrder.mock.funcUpdateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateOrder.mock.afterUpdateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateOrder implements mm_repository.OrderRepository
func (mmUpdateOrder *OrderRepositoryMock) UpdateOrder(ctx context.Context, order *domain.Order) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrder.beforeUpdateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrder.afterUpdateOrderCounter, 1)

	mmUpdateOrder.t.Helper()

	if mmUpdateOrder.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.inspectFuncUpdateOrder(ctx, order)
	}

	mm_params := OrderRepositoryMockUpdateOrderParams{ctx, order}

	// Record call args
	mmUpdateOrder.UpdateOrderMock.mutex.Lock()
	mmUpdateOrder.UpdateOrderMock.callArgs = append(mmUpdateOrder.UpdateOrderMock.callArgs, &mm_params)
	mmUpdateOrder.UpdateOrderMock.mutex.Unlock()

	for _, e := range mmUpdateOrder.UpdateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrder.UpdateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrder.UpdateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrder.UpdateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrder.UpdateOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockUpdateOrderParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrder.t.Errorf("OrderRepositoryMock.UpdateOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrder.UpdateOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmUpdateOrder.t.Errorf("OrderRepositoryMock.UpdateOrder got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrder.UpdateOrderMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrder.t.Errorf("OrderRepositoryMock.UpdateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateOrder.UpdateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrder.UpdateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrder.t.Fatal("No results are set for the OrderRepositoryMock.UpdateOrder")
		}
		return (*mm_results).err
	}
	if mmUpdateOrder.funcUpdateOrder != nil {
		return mmUpdateOrder.funcUpdateOrder(ctx, order)
	}
	mmUpdateOrder.t.Fatalf("Unexpected call to OrderRepositoryMock.UpdateOrder. %v %v", ctx, order)
	return
}

// UpdateOrderAfterCounter returns a count of finished OrderRepositoryMock.UpdateOrder invocations
func (mmUpdateOrder *OrderRepositoryMock) UpdateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.afterUpdateOrderCounter)
}

// UpdateOrderBeforeCounter returns a count of OrderRepositoryMock.UpdateOrder invocations
func (mmUpdateOrder *OrderRepositoryMock) UpdateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.beforeUpdateOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.UpdateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrder *mOrderRepositoryMockUpdateOrder) Calls() []*OrderRepositoryMockUpdateOrderParams {
	mmUpdateOrder.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockUpdateOrderParams, len(mmUpdateOrder.callArgs))
	copy(argCopy, mmUpdateOrder.callArgs)

	mmUpdateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderDone returns true if the count of the UpdateOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockUpdateOrderDone() bool {
	if m.UpdateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateOrderMock.invocationsDone()
}

// MinimockUpdateOrderInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockUpdateOrderInspect() {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.UpdateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateOrderCounter := mm_atomic.LoadUint64(&m.afterUpdateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && afterUpdateOrderCounter < 1 {
		if m.UpdateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.UpdateOrder at\n%s", m.UpdateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.UpdateOrder at\n%s with params: %#v", m.UpdateOrderMock.defaultExpectation.expectationOrigins.origin, *m.UpdateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && afterUpdateOrderCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.UpdateOrder at\n%s", m.funcUpdateOrderOrigin)
	}

	if !m.UpdateOrderMock.invocationsDone() && afterUpdateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.UpdateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateOrderMock.expectedInvocations), m.UpdateOrderMock.expectedInvocationsOrigin, afterUpdateOrderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddOrderInspect()

			m.MinimockDeleteOrderInspect()

			m.MinimockGetOrderInspect()

			m.MinimockListOrdersInspect()

			m.MinimockUpdateOrderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddOrderDone() &&
		m.MinimockDeleteOrderDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockListOrdersDone() &&
		m.MinimockUpdateOrderDone()
}
